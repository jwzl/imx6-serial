diff --git a/arch/arm/boot/dts/Makefile b/arch/arm/boot/dts/Makefile
old mode 100644
new mode 100755
diff --git a/arch/arm/boot/dts/imx6qp-sabreauto-ecspi.dts b/arch/arm/boot/dts/imx6qp-sabreauto-ecspi.dts
old mode 100644
new mode 100755
diff --git a/arch/arm/configs/imx_v7_adv_android_defconfig b/arch/arm/configs/imx_v7_adv_android_defconfig
index adb4dda..5353a44 100755
--- a/arch/arm/configs/imx_v7_adv_android_defconfig
+++ b/arch/arm/configs/imx_v7_adv_android_defconfig
@@ -23,13 +23,14 @@ CONFIG_MODULE_SRCVERSION_ALL=y
 # CONFIG_BLK_DEV_BSG is not set
 CONFIG_ARCH_MXC=y
 CONFIG_ARCH_ADVANTECH=y
-CONFIG_SOC_IMX50=y
+CONFIG_IMXIMX50=y
 CONFIG_SOC_IMX53=y
 CONFIG_SOC_IMX6Q=y
 CONFIG_SOC_IMX6SL=y
 CONFIG_SOC_IMX6SX=y
 CONFIG_SOC_VF610=y
 CONFIG_MXC_REBOOT_ANDROID_CMD=y
+CONFIG_MX6_CLK_FOR_BOOTUI_TRANS=y
 # CONFIG_SWP_EMULATE is not set
 CONFIG_MX6_RAMOOPS=y
 CONFIG_ARM_KERNMEM_PERMS=y
@@ -400,9 +401,6 @@ CONFIG_FB_MXC_CH7055=y
 CONFIG_LCD_L4F00242T03=m
 CONFIG_LCD_PLATFORM=m
 CONFIG_BACKLIGHT_PWM=y
-CONFIG_FRAMEBUFFER_CONSOLE=m
-CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
-CONFIG_LOGO=y
 CONFIG_SOUND=y
 CONFIG_SND=y
 CONFIG_SND_USB_AUDIO=y
diff --git a/arch/arm/mach-imx/Kconfig b/arch/arm/mach-imx/Kconfig
old mode 100644
new mode 100755
index 807186e..6c0953c
--- a/arch/arm/mach-imx/Kconfig
+++ b/arch/arm/mach-imx/Kconfig
@@ -589,6 +589,15 @@ config SOC_IMX6Q
 	help
 	  This enables support for Freescale i.MX6 Quad processor.
 
+config MX6_CLK_FOR_BOOTUI_TRANS
+	bool "MX6 clk setting for smooth UI transtion from bootloader to kernel"
+	depends on SOC_IMX6Q
+	default n
+	help
+	 This is choosed to keep enable IPU related clocks and PWM clocks and
+	 avoid setting IPU related clocks' parents when initializing clock tree
+	 so that bootloader splashimage can transition to kernel smoothly.
+
 config SOC_IMX6SL
 	bool "i.MX6 SoloLite support"
 	select HAVE_IMX_RNG
diff --git a/arch/arm/mach-imx/Makefile b/arch/arm/mach-imx/Makefile
old mode 100644
new mode 100755
diff --git a/arch/arm/mach-imx/clk-imx6q.c b/arch/arm/mach-imx/clk-imx6q.c
old mode 100644
new mode 100755
index f45de65..71294b1
--- a/arch/arm/mach-imx/clk-imx6q.c
+++ b/arch/arm/mach-imx/clk-imx6q.c
@@ -19,7 +19,9 @@
 #include <linux/of.h>
 #include <linux/of_address.h>
 #include <linux/of_irq.h>
+#include <linux/mxcfb.h>
 #include <dt-bindings/clock/imx6qdl-clock.h>
+#include <linux/string.h>
 
 #include "clk.h"
 #include "common.h"
@@ -302,7 +304,26 @@ static void init_ldb_clks(struct device_node *np)
 	ldb_di0_sel[2] = ldb_di0_sel[3] | 4;	/* Change the upper mux while lower mux is selected. */
 	ldb_di1_sel[1] = ldb_di1_sel[0] | 4;
 	ldb_di1_sel[2] = ldb_di1_sel[3] | 4;
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+	if(mxcfb_early_get_logo_status("ldb")){
+		/* Skip ldb clock source assign*/
+		pr_warn("##### Skip ldb clock source assign ### \r\n");
+		return;
+	}else{
+		mmdc_ch1_handshake(false);
+		mmdc_ch1_disable();
+
+		for (i = 1; i < 4; i++) {
+			reg = readl_relaxed(ccm_base + CCM_CS2CDR);
+			reg &= ~((7 << 9) | (7 << 12));
+			reg |= ((ldb_di0_sel[i] << 9) | (ldb_di1_sel[i] << 12));
+			writel_relaxed(reg, ccm_base + CCM_CS2CDR);
+		}
 
+		mmdc_ch1_reenable();
+		mmdc_ch1_handshake(true);
+	}	
+#else
 	mmdc_ch1_handshake(false);
 	mmdc_ch1_disable();
 
@@ -315,12 +336,19 @@ static void init_ldb_clks(struct device_node *np)
 
 	mmdc_ch1_reenable();
 	mmdc_ch1_handshake(true);
+#endif
 }
 
 static void disable_anatop_clocks(void)
 {
 	u32 reg;
 
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+	if(mxcfb_early_get_logo_status("ldb")){
+		return;
+	}
+#else
+
 	/* Make sure PFDs are disabled at boot. */
 	reg = readl_relaxed(anatop_base + 0x100);
 	/* Cannot gate pll2_pfd2_396m if its the parent of MMDC clock */
@@ -340,8 +368,39 @@ static void disable_anatop_clocks(void)
 	reg = readl_relaxed(anatop_base + 0xa0);
 	reg &= ~(1 << 13);
 	writel_relaxed(reg, anatop_base + 0xa0);
+#endif
 }
 
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+int imx_ipuclk_set_parent(char*dev, int ipu_id, int ipu_di)
+{	
+	/* Assigned the IPU DI clock*/
+	if (!strncmp(dev, "ldb", 3)){
+		if(ipu_id ==0 && ipu_di == 0){
+			if (cpu_is_imx6q() && imx_get_soc_revision() == IMX_CHIP_REVISION_2_0) {
+				imx_clk_set_parent(clk[IMX6QDL_CLK_IPU1_DI0_SEL], clk[IMX6QDL_CLK_LDB_DI0_DIV_SEL]);
+			}else {
+				imx_clk_set_parent(clk[IMX6QDL_CLK_IPU1_DI0_SEL], clk[IMX6QDL_CLK_LDB_DI0]);
+			}	
+		}else if(ipu_id ==0 && ipu_di == 1){
+			if (cpu_is_imx6q() && imx_get_soc_revision() == IMX_CHIP_REVISION_2_0) {
+				imx_clk_set_parent(clk[IMX6QDL_CLK_IPU1_DI1_SEL], clk[IMX6QDL_CLK_LDB_DI1_DIV_SEL]);
+			}else {
+				imx_clk_set_parent(clk[IMX6QDL_CLK_IPU1_DI1_SEL], clk[IMX6QDL_CLK_LDB_DI1]);
+			}
+		}else if(ipu_id ==1 && ipu_di == 1){
+			if (cpu_is_imx6q() && imx_get_soc_revision() == IMX_CHIP_REVISION_2_0) {
+				imx_clk_set_parent(clk[IMX6QDL_CLK_IPU2_DI1_SEL], clk[IMX6QDL_CLK_LDB_DI1_DIV_SEL]);
+			}else {
+				imx_clk_set_parent(clk[IMX6QDL_CLK_IPU2_DI1_SEL], clk[IMX6QDL_CLK_LDB_DI1]);
+			} 	
+		}
+	}
+
+	return 0;
+}
+#endif
+
 static void __init imx6q_clocks_init(struct device_node *ccm_node)
 {
 	struct device_node *np;
@@ -795,10 +854,40 @@ static void __init imx6q_clocks_init(struct device_node *ccm_node)
 	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU1_DI1_PRE_SEL], clk[IMX6QDL_CLK_PLL5_VIDEO_DIV]);
 	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU2_DI0_PRE_SEL], clk[IMX6QDL_CLK_PLL5_VIDEO_DIV]);
 	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU2_DI1_PRE_SEL], clk[IMX6QDL_CLK_PLL5_VIDEO_DIV]);
+/* #ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+#if defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LCD_IPU1_DI0)
+	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU1_DI0_SEL], clk[IMX6QDL_CLK_IPU1_DI0_PRE]);
+	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU1_DI1_SEL], clk[IMX6QDL_CLK_IPU1_DI1_PRE]);
+	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU2_DI0_SEL], clk[IMX6QDL_CLK_IPU2_DI0_PRE]);
+	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU2_DI1_SEL], clk[IMX6QDL_CLK_IPU2_DI1_PRE]);
+#endif
+
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU1_DI0
+	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU1_DI0_SEL], clk[IMX6QDL_CLK_LDB_DI0]);
+	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU1_DI1_SEL], clk[IMX6QDL_CLK_IPU1_DI1_PRE]);
+	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU2_DI0_SEL], clk[IMX6QDL_CLK_IPU2_DI0_PRE]);
+	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU2_DI1_SEL], clk[IMX6QDL_CLK_IPU2_DI1_PRE]);
+#endif
+
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU1_DI1
+	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU1_DI0_SEL], clk[IMX6QDL_CLK_IPU1_DI0_PRE]);
+	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU1_DI1_SEL], clk[IMX6QDL_CLK_LDB_DI1]);
+	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU2_DI0_SEL], clk[IMX6QDL_CLK_IPU2_DI0_PRE]);
+	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU2_DI1_SEL], clk[IMX6QDL_CLK_IPU2_DI1_PRE]);
+#endif
+
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU2_DI1
+	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU1_DI0_SEL], clk[IMX6QDL_CLK_IPU1_DI0_PRE]);
+	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU1_DI1_SEL], clk[IMX6QDL_CLK_IPU1_DI1_PRE]);
+	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU2_DI0_SEL], clk[IMX6QDL_CLK_IPU2_DI0_PRE]);
+	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU2_DI1_SEL], clk[IMX6QDL_CLK_LDB_DI1]);
+#endif
+#else  */
 	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU1_DI0_SEL], clk[IMX6QDL_CLK_IPU1_DI0_PRE]);
 	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU1_DI1_SEL], clk[IMX6QDL_CLK_IPU1_DI1_PRE]);
 	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU2_DI0_SEL], clk[IMX6QDL_CLK_IPU2_DI0_PRE]);
 	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU2_DI1_SEL], clk[IMX6QDL_CLK_IPU2_DI1_PRE]);
+/* #endif */
 	if (cpu_is_imx6dl()) {
 		imx_clk_set_rate(clk[IMX6QDL_CLK_PLL3_PFD1_540M], 540000000);
 		imx_clk_set_parent(clk[IMX6QDL_CLK_IPU1_SEL], clk[IMX6QDL_CLK_PLL3_PFD1_540M]);
diff --git a/arch/arm/mach-imx/mach-imx6q.c b/arch/arm/mach-imx/mach-imx6q.c
old mode 100644
new mode 100755
index 95a6377..5edb08a
--- a/arch/arm/mach-imx/mach-imx6q.c
+++ b/arch/arm/mach-imx/mach-imx6q.c
@@ -542,6 +542,26 @@ static void imx6q_reserve(void)
 	struct meminfo *mi;
 	struct membank *bank;
 
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+	phys_addr_t base, size;
+
+	/*
+	 * Frame buffer base address.
+	 * It is same as CONFIG_FB_BASE in Uboot.
+	 */
+	base = 0x27800000;
+
+	/*
+	 * Reserved display memory size.
+	 * It should be bigger than 3 x framer buffer size.
+	 * For 1080P 32 bpp, 1920*1080*4*3 = 0x017BB000.
+	 */
+	size = 0x01800000;
+
+	memblock_reserve(base, size);
+	memblock_remove(base, size);
+#endif
+
 #ifdef CONFIG_PSTORE_RAM
 	max_phys = memblock_end_of_DRAM();
 	/* reserve 64M for uboot avoid ram console data is cleaned by uboot */
diff --git a/drivers/input/evdev.c b/drivers/input/evdev.c
old mode 100644
new mode 100755
diff --git a/drivers/mfd/mxc-hdmi-core.c b/drivers/mfd/mxc-hdmi-core.c
index a670406..4fb7696 100644
--- a/drivers/mfd/mxc-hdmi-core.c
+++ b/drivers/mfd/mxc-hdmi-core.c
@@ -549,6 +549,12 @@ static int hdmi_core_get_of_property(struct platform_device *pdev)
 
 /* Need to run this before phy is enabled the first time to prevent
  * overflow condition in HDMI_IH_FC_STAT2 */
+void hdmi_init_pclk(unsigned long pclk)
+{
+	pixel_clk_rate = pclk;
+}
+EXPORT_SYMBOL(hdmi_init_pclk);
+
 void hdmi_init_clk_regenerator(void)
 {
 	if (pixel_clk_rate == 0) {
@@ -792,6 +798,19 @@ static struct platform_driver mxc_hdmi_core_driver = {
 	.remove = __exit_p(mxc_hdmi_core_remove),
 };
 
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+static int __init mxc_hdmi_audio_clock_setup(char *options)
+{
+	if (!strcmp(options, "74250000"))
+		pixel_clk_rate = 74250000;
+	else if (!strcmp(options, "148500000"))
+		pixel_clk_rate = 148500000;
+
+	return 1;
+}
+__setup("hdmi_audio_clk=", mxc_hdmi_audio_clock_setup);
+#endif
+
 static int __init mxc_hdmi_core_init(void)
 {
 	return platform_driver_probe(&mxc_hdmi_core_driver,
diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
old mode 100644
new mode 100755
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
old mode 100644
new mode 100755
diff --git a/drivers/mmc/host/sdhci-esdhc-imx.c b/drivers/mmc/host/sdhci-esdhc-imx.c
old mode 100644
new mode 100755
diff --git a/drivers/mxc/ipu3/ipu_common.c b/drivers/mxc/ipu3/ipu_common.c
index c38f882..b4fac9e 100644
--- a/drivers/mxc/ipu3/ipu_common.c
+++ b/drivers/mxc/ipu3/ipu_common.c
@@ -36,6 +36,7 @@
 #include <linux/reset.h>
 #include <linux/spinlock.h>
 #include <linux/types.h>
+#include <linux/mxcfb.h>
 
 #include <asm/cacheflush.h>
 
@@ -141,111 +142,108 @@ static inline bool idma_is_set(struct ipu_soc *ipu, uint32_t reg, uint32_t dma)
 
 static int ipu_clk_setup_enable(struct ipu_soc *ipu)
 {
-	char pixel_clk_0[] = "ipu1_pclk_0";
-	char pixel_clk_1[] = "ipu1_pclk_1";
-	char pixel_clk_0_sel[] = "ipu1_pclk0_sel";
-	char pixel_clk_1_sel[] = "ipu1_pclk1_sel";
-	char pixel_clk_0_div[] = "ipu1_pclk0_div";
-	char pixel_clk_1_div[] = "ipu1_pclk1_div";
-	char *ipu_pixel_clk_sel[] = { "ipu1", "ipu1_di0", "ipu1_di1", };
-	char *pclk_sel;
+	char pixel_clk[11];
+	char pixel_clk_sel[15];
+	char pixel_clk_div[15];
+	char pixel_clk_parent0[5];
+	char pixel_clk_parent1[9];
+	char *pixel_clk_parents[2];
+	char di_clk[4];
+	char di_clk_sel[8];
 	struct clk *clk;
+	unsigned int di;
+	unsigned int ipu_id;	/* for clk naming */
 	int ret;
-	int i;
 
-	pixel_clk_0[3] += ipu->id;
-	pixel_clk_1[3] += ipu->id;
-	pixel_clk_0_sel[3] += ipu->id;
-	pixel_clk_1_sel[3] += ipu->id;
-	pixel_clk_0_div[3] += ipu->id;
-	pixel_clk_1_div[3] += ipu->id;
-	for (i = 0; i < ARRAY_SIZE(ipu_pixel_clk_sel); i++) {
-		pclk_sel = ipu_pixel_clk_sel[i];
-		pclk_sel[3] += ipu->id;
-	}
 	dev_dbg(ipu->dev, "ipu_clk = %lu\n", clk_get_rate(ipu->ipu_clk));
 
-	clk = clk_register_mux_pix_clk(ipu->dev, pixel_clk_0_sel,
-			(const char **)ipu_pixel_clk_sel,
-			ARRAY_SIZE(ipu_pixel_clk_sel),
-			0, ipu->id, 0, 0);
-	if (IS_ERR(clk)) {
-		dev_err(ipu->dev, "clk_register mux di0 failed");
-		return PTR_ERR(clk);
-	}
-	ipu->pixel_clk_sel[0] = clk;
-	clk = clk_register_mux_pix_clk(ipu->dev, pixel_clk_1_sel,
-			(const char **)ipu_pixel_clk_sel,
-			ARRAY_SIZE(ipu_pixel_clk_sel),
-			0, ipu->id, 1, 0);
-	if (IS_ERR(clk)) {
-		dev_err(ipu->dev, "clk_register mux di1 failed");
-		return PTR_ERR(clk);
-	}
-	ipu->pixel_clk_sel[1] = clk;
-
-	clk = clk_register_div_pix_clk(ipu->dev, pixel_clk_0_div,
-				pixel_clk_0_sel, 0, ipu->id, 0, 0);
-	if (IS_ERR(clk)) {
-		dev_err(ipu->dev, "clk register di0 div failed");
-		return PTR_ERR(clk);
-	}
-	clk = clk_register_div_pix_clk(ipu->dev, pixel_clk_1_div,
-			pixel_clk_1_sel, CLK_SET_RATE_PARENT, ipu->id, 1, 0);
-	if (IS_ERR(clk)) {
-		dev_err(ipu->dev, "clk register di1 div failed");
-		return PTR_ERR(clk);
-	}
-
-	ipu->pixel_clk[0] = clk_register_gate_pix_clk(ipu->dev, pixel_clk_0,
-				pixel_clk_0_div, CLK_SET_RATE_PARENT,
-				ipu->id, 0, 0);
-	if (IS_ERR(ipu->pixel_clk[0])) {
-		dev_err(ipu->dev, "clk register di0 gate failed");
-		return PTR_ERR(ipu->pixel_clk[0]);
-	}
-	ipu->pixel_clk[1] = clk_register_gate_pix_clk(ipu->dev, pixel_clk_1,
-				pixel_clk_1_div, CLK_SET_RATE_PARENT,
-				ipu->id, 1, 0);
-	if (IS_ERR(ipu->pixel_clk[1])) {
-		dev_err(ipu->dev, "clk register di1 gate failed");
-		return PTR_ERR(ipu->pixel_clk[1]);
-	}
-
-	ret = clk_set_parent(ipu->pixel_clk_sel[0], ipu->ipu_clk);
-	if (ret) {
-		dev_err(ipu->dev, "clk set parent failed");
-		return ret;
-	}
+	ipu_id = ipu->id + 1;
+
+	pixel_clk_parents[0] = pixel_clk_parent0;
+	pixel_clk_parents[1] = pixel_clk_parent1;
+
+	for (di = 0; di < 2; di++) {
+		snprintf(pixel_clk_sel, sizeof(pixel_clk_sel),
+				"ipu%u_pclk%u_sel", ipu_id, di);
+		snprintf(pixel_clk_parent0, sizeof(pixel_clk_parent0),
+				"ipu%u", ipu_id);
+		snprintf(pixel_clk_parent1, sizeof(pixel_clk_parent1),
+				"ipu%u_di%u", ipu_id, di);
+		clk = clk_register_mux_pix_clk(ipu->dev, pixel_clk_sel,
+				(const char **)pixel_clk_parents,
+				ARRAY_SIZE(pixel_clk_parents),
+				0, ipu->id, di, 0);
+		if (IS_ERR(clk)) {
+			dev_err(ipu->dev, "di%u mux clk register failed\n", di);
+			return PTR_ERR(clk);
+		}
+		ipu->pixel_clk_sel[di] = clk;
+
+		snprintf(pixel_clk_div, sizeof(pixel_clk_div),
+				"ipu%u_pclk%u_div", ipu_id, di);
+		clk = clk_register_div_pix_clk(ipu->dev, pixel_clk_div,
+					pixel_clk_sel, 0, ipu->id, di, 0);
+		if (IS_ERR(clk)) {
+			dev_err(ipu->dev, "di%u div clk register failed\n", di);
+			return PTR_ERR(clk);
+		}
 
-	ret = clk_set_parent(ipu->pixel_clk_sel[1], ipu->ipu_clk);
-	if (ret) {
-		dev_err(ipu->dev, "clk set parent failed");
-		return ret;
-	}
+		snprintf(pixel_clk, sizeof(pixel_clk),
+				"ipu%u_pclk%u", ipu_id, di);
+		ipu->pixel_clk[di] = clk_register_gate_pix_clk(ipu->dev,
+					pixel_clk, pixel_clk_div,
+					CLK_SET_RATE_PARENT, ipu->id, di, 0);
+		if (IS_ERR(ipu->pixel_clk[di])) {
+			dev_err(ipu->dev,
+					"di%u gate clk register failed\n", di);
+			return PTR_ERR(ipu->pixel_clk[di]);
+		}
 
-	ipu->di_clk[0] = devm_clk_get(ipu->dev, "di0");
-	if (IS_ERR(ipu->di_clk[0])) {
-		dev_err(ipu->dev, "clk_get di0 failed");
-		return PTR_ERR(ipu->di_clk[0]);
-	}
-	ipu->di_clk[1] = devm_clk_get(ipu->dev, "di1");
-	if (IS_ERR(ipu->di_clk[1])) {
-		dev_err(ipu->dev, "clk_get di1 failed");
-		return PTR_ERR(ipu->di_clk[1]);
-	}
+		ret = clk_set_parent(ipu->pixel_clk_sel[di], ipu->ipu_clk);
+		if (ret) {
+			dev_err(ipu->dev, "pixel clk set parent failed\n");
+			return ret;
+		}
 
-	ipu->di_clk_sel[0] = devm_clk_get(ipu->dev, "di0_sel");
-	if (IS_ERR(ipu->di_clk_sel[0])) {
-		dev_err(ipu->dev, "clk_get di0_sel failed");
-		return PTR_ERR(ipu->di_clk_sel[0]);
-	}
-	ipu->di_clk_sel[1] = devm_clk_get(ipu->dev, "di1_sel");
-	if (IS_ERR(ipu->di_clk_sel[1])) {
-		dev_err(ipu->dev, "clk_get di1_sel failed");
-		return PTR_ERR(ipu->di_clk_sel[1]);
+		snprintf(di_clk, sizeof(di_clk), "di%u", di);
+		ipu->di_clk[di] = devm_clk_get(ipu->dev, di_clk);
+		if (IS_ERR(ipu->di_clk[di])) {
+			dev_err(ipu->dev, "di%u clk get failed\n", di);
+			return PTR_ERR(ipu->di_clk[di]);
+		}
+
+		snprintf(di_clk_sel, sizeof(di_clk_sel), "di%u_sel", di);
+		ipu->di_clk_sel[di] = devm_clk_get(ipu->dev, di_clk_sel);
+		if (IS_ERR(ipu->di_clk_sel[di])) {
+			dev_err(ipu->dev, "di%u sel clk get failed\n", di);
+			return PTR_ERR(ipu->di_clk_sel[di]);
+		}
 	}
 
+/*  #ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+#if defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LCD_IPU1_DI0) ||\
+	defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_HDMI_IPU1_DI0) ||\
+	defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU1_DI0)
+	if (ipu->id == 0)
+		clk_set_parent(ipu->pixel_clk_sel[0], ipu->di_clk[0]);
+#endif
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_HDMI_IPU2_DI0
+	if (ipu->id == 1)
+		clk_set_parent(ipu->pixel_clk_sel[0], ipu->di_clk[0]);
+#endif
+
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU1_DI1
+	if (ipu->id == 0)
+		clk_set_parent(ipu->pixel_clk_sel[1], ipu->di_clk[1]);
+#endif
+
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU2_DI1
+	if (ipu->id == 1)
+		clk_set_parent(ipu->pixel_clk_sel[1], ipu->di_clk[1]);
+#endif
+
+#endif */
+
 	return 0;
 }
 
@@ -499,7 +497,11 @@ static int ipu_probe(struct platform_device *pdev)
 		dev_dbg(&pdev->dev, "can not get alias id\n");
 		return id;
 	}
-
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+	/* Check the ipu bypass-reset status from command line.*/
+	if(mxcfb_early_check_ipu_bypass_reset_status(id))
+		bypass_reset = 1;
+#endif
 	ipu = &ipu_array[id];
 	memset(ipu, 0, sizeof(struct ipu_soc));
 	ipu->bypass_reset = (bool)bypass_reset;
@@ -637,7 +639,12 @@ static int ipu_probe(struct platform_device *pdev)
 		ipu_cm_write(ipu, 0x00400000L | (IPU_MCU_T_DEFAULT << 18),
 			     IPU_DISP_GEN);
 	}
-
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+	else {
+		ipu->fg_csc_type = ipu->bg_csc_type = CSC_NONE;
+		ipu->color_key_4rgb = true;
+	}
+#endif
 	/* setup ipu clk tree after ipu reset  */
 	ret = ipu_clk_setup_enable(ipu);
 	if (ret < 0) {
@@ -3519,3 +3526,531 @@ static void __exit ipu_gen_uninit(void)
 }
 
 module_exit(ipu_gen_uninit);
+
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+/*!
+ * This function is called to initialize a logical IPU channel.
+ *
+ * @param	ipu	ipu handler
+ * @param       channel Input parameter for the logical channel ID to init.
+ *
+ * @param       params  Input parameter containing union of channel
+ *                      initialization parameters.
+ *
+ * @return      Returns 0 on success or negative error code on fail
+ */
+int32_t ipu_init_channel_late_init(struct ipu_soc *ipu, ipu_channel_t channel, ipu_channel_params_t *params)
+{
+	int ret = 0;
+	uint32_t ipu_conf;
+
+	dev_dbg(ipu->dev, "init channel = %d\n", IPU_CHAN_ID(channel));
+
+	ret = pm_runtime_get_sync(ipu->dev);
+	if (ret < 0) {
+		dev_err(ipu->dev, "ch = %d, pm_runtime_get failed:%d!\n",
+				IPU_CHAN_ID(channel), ret);
+		dump_stack();
+		return ret;
+	}
+	/*
+	 * Here, ret could be 1 if the device's runtime PM status was
+	 * already 'active', so clear it to be 0.
+	 */
+	ret = 0;
+
+	//_ipu_get(ipu);
+
+	mutex_lock(&ipu->mutex_lock);
+
+	/* Re-enable error interrupts every time a channel is initialized */
+	ipu_cm_write(ipu, 0xFFFFFFFF, IPU_INT_CTRL(5));
+	ipu_cm_write(ipu, 0xFFFFFFFF, IPU_INT_CTRL(6));
+	ipu_cm_write(ipu, 0xFFFFFFFF, IPU_INT_CTRL(9));
+	ipu_cm_write(ipu, 0xFFFFFFFF, IPU_INT_CTRL(10));
+
+	if (ipu->channel_init_mask & (1L << IPU_CHAN_ID(channel))) {
+		dev_warn(ipu->dev, "Warning: channel already initialized %d\n",
+			IPU_CHAN_ID(channel));
+	}
+
+	ipu_conf = ipu_cm_read(ipu, IPU_CONF);
+
+	switch (channel) {
+	case MEM_DC_SYNC:
+		if (params->mem_dc_sync.di > 1) {
+			ret = -EINVAL;
+			goto err;
+		}
+
+		ipu->dc_di_assignment[1] = params->mem_dc_sync.di;
+//		_ipu_dc_init(ipu, 1, params->mem_dc_sync.di,
+//			     params->mem_dc_sync.interlaced,
+//			     params->mem_dc_sync.out_pixel_fmt);
+		ipu->di_use_count[params->mem_dc_sync.di]++;
+		ipu->dc_use_count++;
+		ipu->dmfc_use_count++;
+		break;
+	case MEM_BG_SYNC:
+		if (params->mem_dp_bg_sync.di > 1) {
+			ret = -EINVAL;
+			goto err;
+		}
+
+		if (params->mem_dp_bg_sync.alpha_chan_en)
+			ipu->thrd_chan_en[IPU_CHAN_ID(channel)] = true;
+
+		ipu->dc_di_assignment[5] = params->mem_dp_bg_sync.di;
+//		_ipu_dp_init(ipu, channel, params->mem_dp_bg_sync.in_pixel_fmt,
+//			     params->mem_dp_bg_sync.out_pixel_fmt);
+//		_ipu_dc_init(ipu, 5, params->mem_dp_bg_sync.di,
+//			     params->mem_dp_bg_sync.interlaced,
+//			     params->mem_dp_bg_sync.out_pixel_fmt);
+		ipu->di_use_count[params->mem_dp_bg_sync.di]++;
+		ipu->dc_use_count++;
+		ipu->dp_use_count++;
+		ipu->dmfc_use_count++;
+		break;
+	case MEM_FG_SYNC:
+		_ipu_dp_init(ipu, channel, params->mem_dp_fg_sync.in_pixel_fmt,
+			     params->mem_dp_fg_sync.out_pixel_fmt);
+
+		if (params->mem_dp_fg_sync.alpha_chan_en)
+			ipu->thrd_chan_en[IPU_CHAN_ID(channel)] = true;
+
+		ipu->dc_use_count++;
+		ipu->dp_use_count++;
+		ipu->dmfc_use_count++;
+		break;
+	default:
+		dev_err(ipu->dev, "Missing channel initialization\n");
+		break;
+	}
+
+	ipu->channel_init_mask |= 1L << IPU_CHAN_ID(channel);
+
+	ipu_cm_write(ipu, ipu_conf, IPU_CONF);
+
+err:
+	mutex_unlock(&ipu->mutex_lock);
+	return ret;
+}
+EXPORT_SYMBOL(ipu_init_channel_late_init);
+
+/*!
+ * This function is called to initialize buffer(s) for logical IPU channel.
+ *
+ * @param	ipu		ipu handler
+ *
+ * @param       channel         Input parameter for the logical channel ID.
+ *
+ * @param       type            Input parameter which buffer to initialize.
+ *
+ * @param       pixel_fmt       Input parameter for pixel format of buffer.
+ *                              Pixel format is a FOURCC ASCII code.
+ *
+ * @param       width           Input parameter for width of buffer in pixels.
+ *
+ * @param       height          Input parameter for height of buffer in pixels.
+ *
+ * @param       stride          Input parameter for stride length of buffer
+ *                              in pixels.
+ *
+ * @param       rot_mode        Input parameter for rotation setting of buffer.
+ *                              A rotation setting other than
+ *                              IPU_ROTATE_VERT_FLIP
+ *                              should only be used for input buffers of
+ *                              rotation channels.
+ *
+ * @param       phyaddr_0       Input parameter buffer 0 physical address.
+ *
+ * @param       phyaddr_1       Input parameter buffer 1 physical address.
+ *                              Setting this to a value other than NULL enables
+ *                              double buffering mode.
+ *
+ * @param       phyaddr_2       Input parameter buffer 2 physical address.
+ *                              Setting this to a value other than NULL enables
+ *                              triple buffering mode, phyaddr_1 should not be
+ *                              NULL then.
+ *
+ * @param       u		private u offset for additional cropping,
+ *				zero if not used.
+ *
+ * @param       v		private v offset for additional cropping,
+ *				zero if not used.
+ *
+ * @return      Returns 0 on success or negative error code on fail
+ */
+int32_t ipu_init_channel_buffer_late_init(struct ipu_soc *ipu, ipu_channel_t channel,
+				ipu_buffer_t type,
+				uint32_t pixel_fmt,
+				uint16_t width, uint16_t height,
+				uint32_t stride,
+				ipu_rotate_mode_t rot_mode,
+				dma_addr_t phyaddr_0, dma_addr_t phyaddr_1,
+				dma_addr_t phyaddr_2,
+				uint32_t u, uint32_t v)
+{
+	uint32_t reg;
+	uint32_t dma_chan;
+	uint32_t burst_size;
+
+	dma_chan = channel_2_dma(channel, type);
+	if (!idma_is_valid(dma_chan))
+		return -EINVAL;
+
+	if (stride < width * bytes_per_pixel(pixel_fmt))
+		stride = width * bytes_per_pixel(pixel_fmt);
+
+	if (stride % 4) {
+		dev_err(ipu->dev,
+			"Stride not 32-bit aligned, stride = %d\n", stride);
+		return -EINVAL;
+	}
+	/* IC & IRT channels' width must be multiple of 8 pixels */
+	if ((_ipu_is_ic_chan(dma_chan) || _ipu_is_irt_chan(dma_chan))
+		&& (width % 8)) {
+		dev_err(ipu->dev, "Width must be 8 pixel multiple\n");
+		return -EINVAL;
+	}
+
+	if (_ipu_is_vdi_out_chan(dma_chan) &&
+		((width < 16) || (height < 16) || (width % 2) || (height % 4))) {
+		dev_err(ipu->dev, "vdi width/height limited err\n");
+		return -EINVAL;
+	}
+
+	/* IPUv3EX and IPUv3M support triple buffer */
+	if ((!_ipu_is_trb_chan(ipu, dma_chan)) && phyaddr_2) {
+		dev_err(ipu->dev, "Chan%d doesn't support triple buffer "
+				   "mode\n", dma_chan);
+		return -EINVAL;
+	}
+	if (!phyaddr_1 && phyaddr_2) {
+		dev_err(ipu->dev, "Chan%d's buf1 physical addr is NULL for "
+				   "triple buffer mode\n", dma_chan);
+		return -EINVAL;
+	}
+
+	mutex_lock(&ipu->mutex_lock);
+
+	/* Build parameter memory data for DMA channel */
+	_ipu_ch_param_init(ipu, dma_chan, pixel_fmt, width, height, stride, u, v, 0,
+			   phyaddr_0, phyaddr_1, phyaddr_2);
+
+	/* Set correlative channel parameter of local alpha channel */
+	if ((_ipu_is_ic_graphic_chan(dma_chan) ||
+	     _ipu_is_dp_graphic_chan(dma_chan)) &&
+	    (ipu->thrd_chan_en[IPU_CHAN_ID(channel)] == true)) {
+		_ipu_ch_param_set_alpha_use_separate_channel(ipu, dma_chan, true);
+		_ipu_ch_param_set_alpha_buffer_memory(ipu, dma_chan);
+		_ipu_ch_param_set_alpha_condition_read(ipu, dma_chan);
+		/* fix alpha width as 8 and burst size as 16*/
+		_ipu_ch_params_set_alpha_width(ipu, dma_chan, 8);
+		_ipu_ch_param_set_burst_size(ipu, dma_chan, 16);
+	} else if (_ipu_is_ic_graphic_chan(dma_chan) &&
+		   ipu_pixel_format_has_alpha(pixel_fmt))
+		_ipu_ch_param_set_alpha_use_separate_channel(ipu, dma_chan, false);
+
+	if (rot_mode)
+		_ipu_ch_param_set_rotation(ipu, dma_chan, rot_mode);
+
+	/* IC and ROT channels have restriction of 8 or 16 pix burst length */
+	if (_ipu_is_ic_chan(dma_chan) || _ipu_is_vdi_out_chan(dma_chan)) {
+		if ((width % 16) == 0)
+			_ipu_ch_param_set_burst_size(ipu, dma_chan, 16);
+		else
+			_ipu_ch_param_set_burst_size(ipu, dma_chan, 8);
+	} else if (_ipu_is_irt_chan(dma_chan)) {
+		_ipu_ch_param_set_burst_size(ipu, dma_chan, 8);
+		_ipu_ch_param_set_block_mode(ipu, dma_chan);
+	} else if (_ipu_is_dmfc_chan(dma_chan)) {
+		burst_size = _ipu_ch_param_get_burst_size(ipu, dma_chan);
+//		_ipu_dmfc_set_wait4eot(ipu, dma_chan, width);
+		_ipu_dmfc_set_burst_size(ipu, dma_chan, burst_size);
+	}
+
+	if (_ipu_disp_chan_is_interlaced(ipu, channel) ||
+		ipu->chan_is_interlaced[dma_chan])
+		_ipu_ch_param_set_interlaced_scan(ipu, dma_chan);
+
+	if (_ipu_is_ic_chan(dma_chan) || _ipu_is_irt_chan(dma_chan) ||
+	_ipu_is_vdi_out_chan(dma_chan)) {
+		burst_size = _ipu_ch_param_get_burst_size(ipu, dma_chan);
+		_ipu_ic_idma_init(ipu, dma_chan, width, height, burst_size,
+			rot_mode);
+	} else if (_ipu_is_smfc_chan(dma_chan)) {
+		burst_size = _ipu_ch_param_get_burst_size(ipu, dma_chan);
+		/*
+		 * This is different from IPUv3 spec, but it is confirmed
+		 * in IPUforum that SMFC burst size should be NPB[6:3]
+		 * when IDMAC works in 16-bit generic data mode.
+		 */
+		if (pixel_fmt == IPU_PIX_FMT_GENERIC)
+			/* 8 bits per pixel */
+			burst_size = burst_size >> 4;
+		else if (pixel_fmt == IPU_PIX_FMT_GENERIC_16)
+			/* 16 bits per pixel */
+			burst_size = burst_size >> 3;
+		else
+			burst_size = burst_size >> 2;
+		_ipu_smfc_set_burst_size(ipu, channel, burst_size-1);
+	}
+
+	switch (dma_chan) {
+	case 0:
+	case 1:
+	case 2:
+	case 3:
+		_ipu_ch_param_set_axi_id(ipu, dma_chan, ipu->ch0123_axi);
+		break;
+	case 23:
+		_ipu_ch_param_set_axi_id(ipu, dma_chan, ipu->ch23_axi);
+		break;
+	case 27:
+		_ipu_ch_param_set_axi_id(ipu, dma_chan, ipu->ch27_axi);
+		break;
+	case 28:
+		_ipu_ch_param_set_axi_id(ipu, dma_chan, ipu->ch28_axi);
+		break;
+	default:
+		_ipu_ch_param_set_axi_id(ipu, dma_chan, ipu->normal_axi);
+		break;
+	}
+
+	if (idma_is_set(ipu, IDMAC_CHA_PRI(dma_chan), dma_chan) &&
+	    ipu->devtype == IPUv3H) {
+		uint32_t reg = IDMAC_CH_LOCK_EN_1(ipu->devtype);
+		uint32_t value = 0;
+
+		switch (dma_chan) {
+		case 5:
+			value = 0x3;
+			break;
+		case 11:
+			value = 0x3 << 2;
+			break;
+		case 12:
+			value = 0x3 << 4;
+			break;
+		case 14:
+			value = 0x3 << 6;
+			break;
+		case 15:
+			value = 0x3 << 8;
+			break;
+		case 20:
+			value = 0x3 << 10;
+			break;
+		case 21:
+			value = 0x3 << 12;
+			break;
+		case 22:
+			value = 0x3 << 14;
+			break;
+		case 23:
+			value = 0x3 << 16;
+			break;
+		case 27:
+			value = 0x3 << 18;
+			break;
+		case 28:
+			value = 0x3 << 20;
+			break;
+		case 45:
+			reg = IDMAC_CH_LOCK_EN_2(ipu->devtype);
+			value = 0x3 << 0;
+			break;
+		case 46:
+			reg = IDMAC_CH_LOCK_EN_2(ipu->devtype);
+			value = 0x3 << 2;
+			break;
+		case 47:
+			reg = IDMAC_CH_LOCK_EN_2(ipu->devtype);
+			value = 0x3 << 4;
+			break;
+		case 48:
+			reg = IDMAC_CH_LOCK_EN_2(ipu->devtype);
+			value = 0x3 << 6;
+			break;
+		case 49:
+			reg = IDMAC_CH_LOCK_EN_2(ipu->devtype);
+			value = 0x3 << 8;
+			break;
+		case 50:
+			reg = IDMAC_CH_LOCK_EN_2(ipu->devtype);
+			value = 0x3 << 10;
+			break;
+		default:
+			break;
+		}
+		value |= ipu_idmac_read(ipu, reg);
+		ipu_idmac_write(ipu, value, reg);
+	}
+
+	_ipu_ch_param_dump(ipu, dma_chan);
+
+	if (phyaddr_2 && ipu->devtype >= IPUv3EX) {
+		reg = ipu_cm_read(ipu, IPU_CHA_DB_MODE_SEL(dma_chan));
+		reg &= ~idma_mask(dma_chan);
+		ipu_cm_write(ipu, reg, IPU_CHA_DB_MODE_SEL(dma_chan));
+
+		reg = ipu_cm_read(ipu,
+				IPU_CHA_TRB_MODE_SEL(ipu->devtype, dma_chan));
+		reg |= idma_mask(dma_chan);
+		ipu_cm_write(ipu, reg,
+				IPU_CHA_TRB_MODE_SEL(ipu->devtype, dma_chan));
+
+		/* Set IDMAC third buffer's cpmem number */
+		/* See __ipu_ch_get_third_buf_cpmem_num() for mapping */
+		ipu_idmac_write(ipu, 0x00444047L,
+				IDMAC_SUB_ADDR_4(ipu->devtype));
+		ipu_idmac_write(ipu, 0x46004241L,
+				IDMAC_SUB_ADDR_3(ipu->devtype));
+		ipu_idmac_write(ipu, 0x00000045L,
+				IDMAC_SUB_ADDR_1(ipu->devtype));
+
+		/* Reset to buffer 0 */
+		ipu_cm_write(ipu, tri_cur_buf_mask(dma_chan),
+				IPU_CHA_TRIPLE_CUR_BUF(ipu->devtype, dma_chan));
+	} else {
+		reg = ipu_cm_read(ipu,
+				IPU_CHA_TRB_MODE_SEL(ipu->devtype, dma_chan));
+		reg &= ~idma_mask(dma_chan);
+		ipu_cm_write(ipu, reg,
+				IPU_CHA_TRB_MODE_SEL(ipu->devtype, dma_chan));
+
+		reg = ipu_cm_read(ipu, IPU_CHA_DB_MODE_SEL(dma_chan));
+		if (phyaddr_1)
+			reg |= idma_mask(dma_chan);
+		else
+			reg &= ~idma_mask(dma_chan);
+		ipu_cm_write(ipu, reg, IPU_CHA_DB_MODE_SEL(dma_chan));
+
+		/* Reset to buffer 0 */
+		ipu_cm_write(ipu, idma_mask(dma_chan),
+				IPU_CHA_CUR_BUF(ipu->devtype, dma_chan));
+
+	}
+
+	mutex_unlock(&ipu->mutex_lock);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_init_channel_buffer_late_init);
+
+/*!
+ * This function disables the interrupt for the specified interrupt line.
+ * The interrupt lines are defined in \b ipu_irq_line enum.
+ *
+ * @param	ipu		ipu handler
+ * @param       irq             Interrupt line to disable interrupt for.
+ *
+ */
+void ipu_disable_irq_late_init(struct ipu_soc *ipu, uint32_t irq)
+{
+	uint32_t reg;
+	unsigned long lock_flags;
+
+	spin_lock_irqsave(&ipu->int_reg_spin_lock, lock_flags);
+
+	reg = ipu_cm_read(ipu, IPUIRQ_2_CTRLREG(irq));
+	reg &= ~IPUIRQ_2_MASK(irq);
+	ipu_cm_write(ipu, reg, IPUIRQ_2_CTRLREG(irq));
+
+	spin_unlock_irqrestore(&ipu->int_reg_spin_lock, lock_flags);
+}
+EXPORT_SYMBOL(ipu_disable_irq_late_init);
+
+/*!
+ * This function clears the interrupt for the specified interrupt line.
+ * The interrupt lines are defined in \b ipu_irq_line enum.
+ *
+ * @param	ipu		ipu handler
+ * @param       irq             Interrupt line to clear interrupt for.
+ *
+ */
+void ipu_clear_irq_late_init(struct ipu_soc *ipu, uint32_t irq)
+{
+	unsigned long lock_flags;
+
+	spin_lock_irqsave(&ipu->int_reg_spin_lock, lock_flags);
+
+	ipu_cm_write(ipu, IPUIRQ_2_MASK(irq),
+			IPUIRQ_2_STATREG(ipu->devtype, irq));
+
+	spin_unlock_irqrestore(&ipu->int_reg_spin_lock, lock_flags);
+}
+EXPORT_SYMBOL(ipu_clear_irq_late_init);
+
+/*!
+ * This function registers an interrupt handler function for the specified
+ * interrupt line. The interrupt lines are defined in \b ipu_irq_line enum.
+ *
+ * @param	ipu		ipu handler
+ * @param       irq             Interrupt line to get status for.
+ *
+ * @param       handler         Input parameter for address of the handler
+ *                              function.
+ *
+ * @param       irq_flags       Flags for interrupt mode. Currently not used.
+ *
+ * @param       devname         Input parameter for string name of driver
+ *                              registering the handler.
+ *
+ * @param       dev_id          Input parameter for pointer of data to be
+ *                              passed to the handler.
+ *
+ * @return      This function returns 0 on success or negative error code on
+ *              fail.
+ */
+int ipu_request_irq_late_init(struct ipu_soc *ipu, uint32_t irq,
+		    irqreturn_t(*handler) (int, void *),
+		    uint32_t irq_flags, const char *devname, void *dev_id)
+{
+	uint32_t reg;
+	unsigned long lock_flags;
+	int ret = 0;
+
+	BUG_ON(irq >= IPU_IRQ_COUNT);
+
+	spin_lock_irqsave(&ipu->int_reg_spin_lock, lock_flags);
+
+	if (ipu->irq_list[irq].handler != NULL) {
+		dev_err(ipu->dev,
+			"handler already installed on irq %d\n", irq);
+		ret = -EINVAL;
+		goto out;
+	}
+
+	/*
+	 * Check sync interrupt handler only, since we do nothing for
+	 * error interrupts but than print out register values in the
+	 * error interrupt source handler.
+	 */
+	if (_ipu_is_sync_irq(irq) && (handler == NULL)) {
+		dev_err(ipu->dev, "handler is NULL for sync irq %d\n", irq);
+		ret = -EINVAL;
+		goto out;
+	}
+
+	ipu->irq_list[irq].handler = handler;
+	ipu->irq_list[irq].flags = irq_flags;
+	ipu->irq_list[irq].dev_id = dev_id;
+	ipu->irq_list[irq].name = devname;
+
+	/* clear irq stat for previous use */
+	ipu_cm_write(ipu, IPUIRQ_2_MASK(irq),
+			IPUIRQ_2_STATREG(ipu->devtype, irq));
+	/* enable the interrupt */
+	reg = ipu_cm_read(ipu, IPUIRQ_2_CTRLREG(irq));
+	reg |= IPUIRQ_2_MASK(irq);
+	ipu_cm_write(ipu, reg, IPUIRQ_2_CTRLREG(irq));
+out:
+	spin_unlock_irqrestore(&ipu->int_reg_spin_lock, lock_flags);
+
+	return ret;
+}
+EXPORT_SYMBOL(ipu_request_irq_late_init);
+#endif
+
diff --git a/drivers/mxc/ipu3/ipu_disp.c b/drivers/mxc/ipu3/ipu_disp.c
index f2ccb1e..a366275 100644
--- a/drivers/mxc/ipu3/ipu_disp.c
+++ b/drivers/mxc/ipu3/ipu_disp.c
@@ -1979,3 +1979,159 @@ void ipu_disp_init(struct ipu_soc *ipu)
 	_ipu_init_dc_mappings(ipu);
 	_ipu_dmfc_init(ipu, DMFC_NORMAL, 1);
 }
+
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+
+/*!
+ * This function sets the foreground and background plane global alpha blending
+ * modes. This function also sets the DP graphic plane according to the
+ * parameter of IPUv3 DP channel.
+ *
+ * @param	ipu		ipu handler
+ * @param	channel		IPUv3 DP channel
+ *
+ * @param       enable          Boolean to enable or disable global alpha
+ *                              blending. If disabled, local blending is used.
+ *
+ * @param       alpha           Global alpha value.
+ *
+ * @return      Returns 0 on success or negative error code on fail
+ */
+int32_t ipu_disp_set_global_alpha_late_init(struct ipu_soc *ipu, ipu_channel_t channel,
+				bool enable, uint8_t alpha)
+{
+	uint32_t reg;
+	uint32_t flow;
+	bool bg_chan;
+
+	if (channel == MEM_BG_SYNC || channel == MEM_FG_SYNC)
+		flow = DP_SYNC;
+	else if (channel == MEM_BG_ASYNC0 || channel == MEM_FG_ASYNC0)
+		flow = DP_ASYNC0;
+	else if (channel == MEM_BG_ASYNC1 || channel == MEM_FG_ASYNC1)
+		flow = DP_ASYNC1;
+	else
+		return -EINVAL;
+
+	if (channel == MEM_BG_SYNC || channel == MEM_BG_ASYNC0 ||
+	    channel == MEM_BG_ASYNC1)
+		bg_chan = true;
+	else
+		bg_chan = false;
+
+	mutex_lock(&ipu->mutex_lock);
+
+	if (bg_chan) {
+		reg = ipu_dp_read(ipu, DP_COM_CONF(flow));
+		ipu_dp_write(ipu, reg & ~DP_COM_CONF_GWSEL, DP_COM_CONF(flow));
+	} else {
+		reg = ipu_dp_read(ipu, DP_COM_CONF(flow));
+		ipu_dp_write(ipu, reg | DP_COM_CONF_GWSEL, DP_COM_CONF(flow));
+	}
+
+	if (enable) {
+		reg = ipu_dp_read(ipu, DP_GRAPH_WIND_CTRL(flow)) & 0x00FFFFFFL;
+		ipu_dp_write(ipu, reg | ((uint32_t) alpha << 24),
+			     DP_GRAPH_WIND_CTRL(flow));
+
+		reg = ipu_dp_read(ipu, DP_COM_CONF(flow));
+		ipu_dp_write(ipu, reg | DP_COM_CONF_GWAM, DP_COM_CONF(flow));
+	} else {
+		reg = ipu_dp_read(ipu, DP_COM_CONF(flow));
+		ipu_dp_write(ipu, reg & ~DP_COM_CONF_GWAM, DP_COM_CONF(flow));
+	}
+
+	reg = ipu_cm_read(ipu, IPU_SRM_PRI2) | 0x8;
+	ipu_cm_write(ipu, reg, IPU_SRM_PRI2);
+
+	mutex_unlock(&ipu->mutex_lock);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_disp_set_global_alpha_late_init);
+
+/*!
+ * This function sets the transparent color key for SDC graphic plane.
+ *
+ * @param	ipu		ipu handler
+ * @param       channel         Input parameter for the logical channel ID.
+ *
+ * @param       enable          Boolean to enable or disable color key
+ *
+ * @param       colorKey        24-bit RGB color for transparent color key.
+ *
+ * @return      Returns 0 on success or negative error code on fail
+ */
+int32_t ipu_disp_set_color_key_late_init(struct ipu_soc *ipu, ipu_channel_t channel,
+				bool enable, uint32_t color_key)
+{
+	uint32_t reg, flow;
+	int y, u, v;
+	int red, green, blue;
+
+	if (channel == MEM_BG_SYNC || channel == MEM_FG_SYNC)
+		flow = DP_SYNC;
+	else if (channel == MEM_BG_ASYNC0 || channel == MEM_FG_ASYNC0)
+		flow = DP_ASYNC0;
+	else if (channel == MEM_BG_ASYNC1 || channel == MEM_FG_ASYNC1)
+		flow = DP_ASYNC1;
+	else
+		return -EINVAL;
+
+	mutex_lock(&ipu->mutex_lock);
+
+	ipu->color_key_4rgb = true;
+	/* Transform color key from rgb to yuv if CSC is enabled */
+	if (((ipu->fg_csc_type == RGB2YUV) && (ipu->bg_csc_type == YUV2YUV)) ||
+			((ipu->fg_csc_type == YUV2YUV) && (ipu->bg_csc_type == RGB2YUV)) ||
+			((ipu->fg_csc_type == YUV2YUV) && (ipu->bg_csc_type == YUV2YUV)) ||
+			((ipu->fg_csc_type == YUV2RGB) && (ipu->bg_csc_type == YUV2RGB))) {
+
+		dev_dbg(ipu->dev, "color key 0x%x need change to yuv fmt\n", color_key);
+
+		red = (color_key >> 16) & 0xFF;
+		green = (color_key >> 8) & 0xFF;
+		blue = color_key & 0xFF;
+
+		y = _rgb_to_yuv(0, red, green, blue);
+		u = _rgb_to_yuv(1, red, green, blue);
+		v = _rgb_to_yuv(2, red, green, blue);
+		color_key = (y << 16) | (u << 8) | v;
+
+		ipu->color_key_4rgb = false;
+
+		dev_dbg(ipu->dev, "color key change to yuv fmt 0x%x\n", color_key);
+	}
+
+	if (enable) {
+		reg = ipu_dp_read(ipu, DP_GRAPH_WIND_CTRL(flow)) & 0xFF000000L;
+		ipu_dp_write(ipu, reg | color_key, DP_GRAPH_WIND_CTRL(flow));
+
+		reg = ipu_dp_read(ipu, DP_COM_CONF(flow));
+		ipu_dp_write(ipu, reg | DP_COM_CONF_GWCKE, DP_COM_CONF(flow));
+	} else {
+		reg = ipu_dp_read(ipu, DP_COM_CONF(flow));
+		ipu_dp_write(ipu, reg & ~DP_COM_CONF_GWCKE, DP_COM_CONF(flow));
+	}
+
+	reg = ipu_cm_read(ipu, IPU_SRM_PRI2) | 0x8;
+	ipu_cm_write(ipu, reg, IPU_SRM_PRI2);
+
+	mutex_unlock(&ipu->mutex_lock);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_disp_set_color_key_late_init);
+
+int32_t ipu_disp_get_window_pos_late_init(struct ipu_soc *ipu, ipu_channel_t channel,
+				int16_t *x_pos, int16_t *y_pos)
+{
+	int ret;
+
+	mutex_lock(&ipu->mutex_lock);
+	ret = _ipu_disp_get_window_pos(ipu, channel, x_pos, y_pos);
+	mutex_unlock(&ipu->mutex_lock);
+	return ret;
+}
+EXPORT_SYMBOL(ipu_disp_get_window_pos_late_init);
+#endif
diff --git a/drivers/video/backlight/backlight.c b/drivers/video/backlight/backlight.c
index c250f4d..c504801 100644
--- a/drivers/video/backlight/backlight.c
+++ b/drivers/video/backlight/backlight.c
@@ -32,9 +32,11 @@ static const char *const backlight_types[] = {
 };
 
 #if defined(CONFIG_OF) && defined(CONFIG_ARCH_ADVANTECH)
+#ifndef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
 extern int first_power_on;
 extern void enable_ldb_bkl_pwm(void);
 #endif
+#endif
 
 #if defined(CONFIG_FB) || (defined(CONFIG_FB_MODULE) && \
 			   defined(CONFIG_BACKLIGHT_CLASS_DEVICE_MODULE))
@@ -68,6 +70,7 @@ static int fb_notifier_callback(struct notifier_block *self,
 					bd->props.fb_blank = FB_BLANK_UNBLANK;
 
 #if defined(CONFIG_OF) && defined(CONFIG_ARCH_ADVANTECH)
+#ifndef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
 					if(first_power_on)
 						printk(KERN_INFO "[LVDS Sequence] 3 Start to enable LVDS pwm.\n");
 
@@ -82,6 +85,9 @@ static int fb_notifier_callback(struct notifier_block *self,
 #else
 					backlight_update_status(bd);
 #endif
+#else
+					backlight_update_status(bd);
+#endif
 
 				}
 			} else if (fb_blank != FB_BLANK_UNBLANK &&
diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index 46612e5..54b36ee 100755
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -137,6 +137,7 @@ static const struct backlight_ops pwm_backlight_ops = {
 
 #ifdef CONFIG_ARCH_ADVANTECH
 int lvds_vcc_enable;
+#ifndef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
 int lvds_bkl_enable;
 int lvds_vcc_delay_value;
 int lvds_bkl_delay_value;
@@ -179,6 +180,7 @@ void enable_ldb_bkl_pwm(void)
 	}
 }
 #endif
+#endif
 
 static int pwm_backlight_parse_dt(struct device *dev,
 				  struct platform_pwm_backlight_data *data)
@@ -232,6 +234,7 @@ static int pwm_backlight_parse_dt(struct device *dev,
 	 *       added.
 	 */
 #ifdef CONFIG_ARCH_ADVANTECH
+#ifndef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
 	lvds_vcc_enable = of_get_named_gpio_flags(node, "lvds-vcc-enable", 0, &lvds_vcc_flag);
 	lvds_bkl_enable = of_get_named_gpio_flags(node, "lvds-bkl-enable", 0, &lvds_bkl_flag);
 	ret = of_property_read_u32(node,"lvds-vcc-delay-time",&lvds_vcc_delay_value);
@@ -245,6 +248,7 @@ static int pwm_backlight_parse_dt(struct device *dev,
 		lvds_bkl_delay_value = 20;
 	}
 #endif
+#endif
 
 	return 0;
 }
@@ -396,11 +400,13 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 	bl->props.brightness = data->dft_brightness;
 
 #if defined(CONFIG_OF) && defined(CONFIG_ARCH_ADVANTECH)
+#ifndef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
 	/* Inorder to power off pwm backlight for SI test */
 	bl->props.fb_blank = FB_BLANK_NORMAL;
 
 	printk(KERN_INFO "[LVDS Sequence] 0 Set to power off pwm backlight at first.\n");
 #endif
+#endif
 
 	backlight_update_status(bl);
 
diff --git a/drivers/video/fbdev/mxc/ldb.c b/drivers/video/fbdev/mxc/ldb.c
index b0ab8a3..340e5f9 100755
--- a/drivers/video/fbdev/mxc/ldb.c
+++ b/drivers/video/fbdev/mxc/ldb.c
@@ -107,6 +107,9 @@ struct ldb_data {
 	struct clk *div_3_5_clk[2];
 	struct clk *div_7_clk[2];
 	struct clk *div_sel_clk[2];
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+	bool fb_reg;
+#endif
 };
 
 static const struct crtc_mux imx6q_lvds0_crtc_mux[] = {
@@ -299,6 +302,15 @@ static const struct of_device_id ldb_dt_ids[] = {
 };
 MODULE_DEVICE_TABLE(of, ldb_dt_ids);
 
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+void ldb_disp_late_init_done(struct mxc_dispdrv_handle *disp)
+{
+	struct ldb_data *ldb = mxc_dispdrv_getdata(disp);
+
+	ldb->fb_reg = true;
+}
+#endif
+
 static int ldb_init(struct mxc_dispdrv_handle *mddh,
 		    struct mxc_dispdrv_setting *setting)
 {
@@ -331,7 +343,11 @@ static int ldb_init(struct mxc_dispdrv_handle *mddh,
 	fb_videomode_to_var(&fbi->var, &fb_vm);
 
 	setting->crtc = chan->crtc;
-
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+	if(mxcfb_has_keeplogo(fbi)){
+		mddh->drv->late_init_done = ldb_disp_late_init_done;
+	}	
+#endif
 	return 0;
 }
 
@@ -435,6 +451,13 @@ static int ldb_setup(struct mxc_dispdrv_handle *mddh,
 	ldb_di_parent = ldb->spl_mode ? ldb->div_3_5_clk[chno] : ldb->div_7_clk[chno];
 #endif
 
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+	if(mxcfb_has_keeplogo(fbi)){
+		if (ldb->fb_reg == false) {
+			return 0;
+		}
+	}
+#endif
 	if (ldb->clk_fixup) {
 		/*
 		 * ldb_di_sel_parent(plls) -> ldb_di_sel -> ldb_di[chno] ->
@@ -537,6 +560,13 @@ static int ldb_enable(struct mxc_dispdrv_handle *mddh,
 
 	bus_mux = ldb->buses[chno];
 
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+	if(mxcfb_has_keeplogo(fbi)){
+		if (ldb->fb_reg == false) {
+			return 0;
+		}
+	}
+#endif
 	if (ldb->spl_mode || ldb->dual_mode) {
 		other_chno = chno ? 0 : 1;
 		clk_prepare_enable(ldb->ldb_di_clk[other_chno]);
@@ -578,6 +608,13 @@ static void ldb_disable(struct mxc_dispdrv_handle *mddh,
 	if (ret < 0)
 		return;
 
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+	if(mxcfb_has_keeplogo(fbi)){
+		if (ldb->fb_reg == false) {
+			return 0;
+		}
+	}
+#endif
 	if (ldb->spl_mode || ldb->dual_mode) {
 		ldb->ctrl &= ~(LDB_CH1_MODE_MASK | LDB_CH0_MODE_MASK);
 		other_chno = chno ? 0 : 1;
diff --git a/drivers/video/fbdev/mxc/mxc_dispdrv.h b/drivers/video/fbdev/mxc/mxc_dispdrv.h
index b9a34b2..023dea9 100644
--- a/drivers/video/fbdev/mxc/mxc_dispdrv.h
+++ b/drivers/video/fbdev/mxc/mxc_dispdrv.h
@@ -40,6 +40,11 @@ struct mxc_dispdrv_driver {
 	void (*disable) (struct mxc_dispdrv_handle *, struct fb_info *);
 	/* display driver setup function, called at early part of fb_set_par */
 	int (*setup) (struct mxc_dispdrv_handle *, struct fb_info *fbi);
+
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+	/* display driver late init done. */
+	void (*late_init_done) (struct mxc_dispdrv_handle *);
+#endif
 };
 
 struct mxc_dispdrv_handle *mxc_dispdrv_register(struct mxc_dispdrv_driver *drv);
@@ -51,4 +56,7 @@ int mxc_dispdrv_setdata(struct mxc_dispdrv_handle *handle, void *data);
 void *mxc_dispdrv_getdata(struct mxc_dispdrv_handle *handle);
 void mxc_dispdrv_setdev(struct mxc_dispdrv_handle *drv_handle, struct device *dev);
 struct device *mxc_dispdrv_getdev(struct mxc_dispdrv_handle *drv_handle);
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+bool  mxcfb_has_keeplogo(struct fb_info *fbi);
+#endif
 #endif
diff --git a/drivers/video/fbdev/mxc/mxc_hdmi.c b/drivers/video/fbdev/mxc/mxc_hdmi.c
old mode 100644
new mode 100755
index 460944e..a53c16c
--- a/drivers/video/fbdev/mxc/mxc_hdmi.c
+++ b/drivers/video/fbdev/mxc/mxc_hdmi.c
@@ -202,7 +202,7 @@ extern const struct fb_videomode mxc_cea_mode[64];
 extern void mxc_hdmi_cec_handle(u16 cec_stat);
 
 static void mxc_hdmi_setup(struct mxc_hdmi *hdmi, unsigned long event);
-static void hdmi_enable_overflow_interrupts(void);
+static void hdmi_enable_overflow_interrupts(struct mxc_hdmi *hdmi);
 static void hdmi_disable_overflow_interrupts(void);
 
 static struct platform_device_id imx_hdmi_devtype[] = {
@@ -1275,7 +1275,7 @@ static void mxc_hdmi_phy_init(struct mxc_hdmi *hdmi)
 		return;
 
 	if (!hdmi->hdmi_data.video_mode.mDVI)
-		hdmi_enable_overflow_interrupts();
+		hdmi_enable_overflow_interrupts(hdmi);
 
 	/*check csc whether needed activated in HDMI mode */
 	cscon = (isColorSpaceConversion(hdmi) &&
@@ -1753,11 +1753,19 @@ static void mxc_hdmi_clear_overflow(struct mxc_hdmi *hdmi)
 		hdmi_writeb(val, HDMI_FC_INVIDCONF);
 }
 
-static void hdmi_enable_overflow_interrupts(void)
+static void hdmi_enable_overflow_interrupts(struct mxc_hdmi *hdmi)
 {
 	pr_debug("%s\n", __func__);
-	hdmi_writeb(0, HDMI_FC_MASK2);
-	hdmi_writeb(0, HDMI_IH_MUTE_FC_STAT2);
+
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+	if(mxcfb_has_keeplogo(hdmi->fbi)){
+		/* Skip */
+	}else
+#endif
+	{
+		hdmi_writeb(0, HDMI_FC_MASK2);
+		hdmi_writeb(0, HDMI_IH_MUTE_FC_STAT2);
+	}
 }
 
 static void hdmi_disable_overflow_interrupts(void)
@@ -2015,6 +2023,9 @@ static void hotplug_worker(struct work_struct *work)
 	unsigned long flags;
 	char event_string[32];
 	char *envp[] = { event_string, NULL };
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+	int edid_status = HDMI_EDID_FAIL;
+#endif
 
 	phy_int_stat = hdmi->latest_intr_stat;
 	phy_int_pol = hdmi_readb(HDMI_PHY_POL0);
@@ -2028,7 +2039,30 @@ static void hotplug_worker(struct work_struct *work)
 		if (phy_int_pol & HDMI_PHY_HPD) {
 			/* Plugin event */
 			dev_dbg(&hdmi->pdev->dev, "EVENT=plugin\n");
-			mxc_hdmi_cable_connected(hdmi);
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+			if(mxcfb_has_keeplogo(hdmi->fbi)){
+				if (hdmi->fb_reg)
+					mxc_hdmi_cable_connected(hdmi);
+				else {
+					hdmi->cable_plugin = true;
+					hdmi_set_blank_state(1);
+					/* Plugin event */
+					dev_dbg(&hdmi->pdev->dev, "cable plugin\n");
+					edid_status = mxc_hdmi_read_edid(hdmi);
+
+					/* Read EDID again if first EDID read failed */
+					if (edid_status == HDMI_EDID_NO_MODES ||
+						edid_status == HDMI_EDID_FAIL) {
+						dev_info(&hdmi->pdev->dev, "Read EDID again\n");
+						edid_status = mxc_hdmi_read_edid(hdmi);
+					}
+				}
+			}else {
+				mxc_hdmi_cable_connected(hdmi);
+			}
+#else
+		    mxc_hdmi_cable_connected(hdmi);
+#endif
 
 			/* Make HPD intr active low to capture unplug event */
 			val = hdmi_readb(HDMI_PHY_POL0);
@@ -2068,6 +2102,12 @@ static void hotplug_worker(struct work_struct *work)
 			mxc_hdmi_cec_handle(0x100);
 #endif
 
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+			if(mxcfb_has_keeplogo(hdmi->fbi)){
+				hdmi->fb_reg = true;
+			}
+#endif
+
 		} else
 			dev_dbg(&hdmi->pdev->dev, "EVENT=none?\n");
 	}
@@ -2280,6 +2320,18 @@ static void mxc_hdmi_setup(struct mxc_hdmi *hdmi, unsigned long event)
 
 }
 
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+void mxc_hdmi_late_init_done(struct mxc_dispdrv_handle *disp)
+{
+	struct mxc_hdmi *hdmi = mxc_dispdrv_getdata(disp);
+
+	dev_dbg(&hdmi->pdev->dev, "%s\n", __func__);
+
+	hdmi->fb_reg = true;
+	hdmi->dft_mode_set = false;
+}
+#endif
+
 /* Wait until we are registered to enable interrupts */
 static void mxc_hdmi_fb_registered(struct mxc_hdmi *hdmi)
 {
@@ -2308,7 +2360,17 @@ static void mxc_hdmi_fb_registered(struct mxc_hdmi *hdmi)
 	/* Unmute interrupts */
 	hdmi_writeb(~HDMI_IH_MUTE_PHY_STAT0_HPD, HDMI_IH_MUTE_PHY_STAT0);
 
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+	if(mxcfb_has_keeplogo(hdmi->fbi)){
+		hdmi->phy_enabled = true;
+		hdmi->blank = FB_BLANK_UNBLANK;
+		/* Skip hdmi->fb_reg. */
+	}else {
+ 		hdmi->fb_reg = true;
+	}
+#else
 	hdmi->fb_reg = true;
+#endif
 
 	spin_unlock_irqrestore(&hdmi->irq_lock, flags);
 
@@ -2339,6 +2401,23 @@ static int mxc_hdmi_fb_event(struct notifier_block *nb,
 
 	case FB_EVENT_MODE_CHANGE:
 		dev_dbg(&hdmi->pdev->dev, "event=FB_EVENT_MODE_CHANGE\n");
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+		if(mxcfb_has_keeplogo(hdmi->fbi)){
+			if (!hdmi->fb_reg) {
+				struct fb_videomode m;
+
+				fb_var_to_videomode(&m, &hdmi->fbi->var);
+				hdmi->blank = FB_BLANK_UNBLANK;
+
+				if (!hdmi->requesting_vga_for_initialization) {
+					/* Save mode if this isn't the result of requesting
+					 * vga default. */
+					memcpy(&hdmi->previous_non_vga_mode, &m,
+							sizeof(struct fb_videomode));
+				}
+			}
+		}
+#endif
 		mode = (struct fb_videomode *)event->data;
 		if (hdmi->fbi != NULL)
 			hdmi->yres_virtual = hdmi->fbi->var.yres_virtual;
@@ -2394,7 +2473,14 @@ static int mxc_hdmi_fb_event(struct notifier_block *nb,
 			clk_enable(hdmi->mipi_core_clk);
 			clk_enable(hdmi->hdmi_iahb_clk);
 			clk_enable(hdmi->hdmi_isfr_clk);
-			mxc_hdmi_phy_init(hdmi);
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+			if(mxcfb_has_keeplogo(hdmi->fbi)){
+				mxc_hdmi_setup(hdmi, val);
+			}else 
+#endif
+			{
+				mxc_hdmi_phy_init(hdmi);
+			}
 		}
 		break;
 
@@ -2691,6 +2777,12 @@ static int mxc_hdmi_disp_init(struct mxc_dispdrv_handle *disp,
 
 	dev_dbg(&hdmi->pdev->dev, "%s exit\n", __func__);
 
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+	if(mxcfb_has_keeplogo(hdmi->fbi)){
+		disp->drv->late_init_done = mxc_hdmi_late_init_done;
+		hdmi_init_pclk(148500000);
+	}	
+#endif
 	hdmi_inited = true;
 
 	return ret;
diff --git a/drivers/video/fbdev/mxc/mxc_ipuv3_fb.c b/drivers/video/fbdev/mxc/mxc_ipuv3_fb.c
old mode 100644
new mode 100755
index 0286c06..c64162e
--- a/drivers/video/fbdev/mxc/mxc_ipuv3_fb.c
+++ b/drivers/video/fbdev/mxc/mxc_ipuv3_fb.c
@@ -51,6 +51,7 @@
 #include <linux/string.h>
 #include <linux/time.h>
 #include <linux/uaccess.h>
+#include <linux/clk-provider.h>
 
 #include "mxc_dispdrv.h"
 
@@ -89,6 +90,9 @@ struct mxcfb_info {
 	bool overlay;
 	bool alpha_chan_en;
 	bool late_init;
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+	bool late_init_idmac_done;
+#endif
 	bool first_set_par;
 	bool resolve;
 	bool prefetch;
@@ -132,6 +136,9 @@ struct mxcfb_info {
 	spinlock_t spin_lock;	/* for PRE small yres cases */
 	struct ipu_pre_context *pre_config;
 	ktime_t vsync_nf_timestamp;
+
+	/* Enable  keep the logo from uboot to kernel */
+	bool		logo;
 };
 
 struct mxcfb_pfmt {
@@ -483,7 +490,15 @@ static int _setup_disp_channel1(struct fb_info *fbi)
 		if (mxc_fbi->alpha_chan_en)
 			params.mem_dp_bg_sync.alpha_chan_en = true;
 	}
-	ipu_init_channel(mxc_fbi->ipu, mxc_fbi->ipu_ch, &params);
+	
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+	if (mxc_fbi->late_init)
+		ipu_init_channel_late_init(mxc_fbi->ipu, mxc_fbi->ipu_ch, &params);
+	else
+		ipu_init_channel(mxc_fbi->ipu, mxc_fbi->ipu_ch, &params);
+#else
+ 	ipu_init_channel(mxc_fbi->ipu, mxc_fbi->ipu_ch, &params);
+#endif
 
 	return 0;
 }
@@ -906,6 +921,29 @@ static int _setup_disp_channel2(struct fb_info *fbi)
 							       IPU_INPUT_BUFFER, 2));
 		}
 	} else if (!mxc_fbi->on_the_fly && !mxc_fbi->prefetch) {
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+		if (mxc_fbi->late_init) {
+			mxc_fbi->cur_ipu_buf = 0;
+			retval = ipu_init_channel_buffer_late_init(mxc_fbi->ipu,
+						 mxc_fbi->ipu_ch, IPU_INPUT_BUFFER,
+						 fbi_to_pixfmt(fbi, false),
+						 fbi->var.xres, fbi->var.yres,
+						 ipu_stride,
+						 fbi->var.rotate,
+						 ipu_base,
+						 ipu_base,
+						 fbi->var.accel_flags &
+						FB_ACCEL_DOUBLE_FLAG ? 0 : ipu_base,
+						 0, 0);
+			if (retval) {
+				dev_err(fbi->device,
+					"ipu_init_channel_buffer error %d\n", retval);
+				return retval;
+			}
+
+			mxc_fbi->late_init_idmac_done = true;
+		} else {
+#endif
 		retval = ipu_init_channel_buffer(mxc_fbi->ipu,
 						 mxc_fbi->ipu_ch, IPU_INPUT_BUFFER,
 						 mxc_fbi->on_the_fly ? mxc_fbi->final_pfmt :
@@ -923,6 +961,9 @@ static int _setup_disp_channel2(struct fb_info *fbi)
 				"ipu_init_channel_buffer error %d\n", retval);
 			return retval;
 		}
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+		}
+#endif
 		/* update u/v offset */
 		if (!mxc_fbi->prefetch)
 			ipu_update_channel_offset(mxc_fbi->ipu, mxc_fbi->ipu_ch,
@@ -968,6 +1009,23 @@ static bool mxcfb_need_to_set_par(struct fb_info *fbi)
 {
 	struct mxcfb_info *mxc_fbi = fbi->par;
 
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+	if (mxc_fbi->late_init) {
+		if ((mxc_fbi->cur_var.xres != fbi->var.xres) ||
+			(mxc_fbi->cur_var.yres != fbi->var.yres) ||
+			(mxc_fbi->cur_var.bits_per_pixel != fbi->var.bits_per_pixel)) {
+			mxc_fbi->late_init = false;
+
+			if (mxc_fbi->dispdrv && mxc_fbi->dispdrv->drv->late_init_done)
+				mxc_fbi->dispdrv->drv->late_init_done(mxc_fbi->dispdrv);
+			return true;
+		}
+
+		if (mxc_fbi->late_init_idmac_done)
+			return false;
+	}
+#endif
+
 	if ((fbi->var.activate & FB_ACTIVATE_FORCE) &&
 	    (fbi->var.activate & FB_ACTIVATE_MASK) == FB_ACTIVATE_NOW)
 		return true;
@@ -1166,6 +1224,42 @@ static int mxcfb_set_par(struct fb_info *fbi)
 	if (on_the_fly)
 		dev_dbg(fbi->device, "Reconfiguring framebuffer on the fly\n");
 
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+	if (mxc_fbi->late_init) {
+		if (ovfbi_enable) {
+			ov_pos_ret = ipu_disp_get_window_pos_late_init(
+							mxc_fbi_fg->ipu, mxc_fbi_fg->ipu_ch,
+							&ov_pos_x, &ov_pos_y);
+			if (ov_pos_ret < 0)
+				dev_err(fbi->device, "Get overlay pos failed, dispdrv:%s.\n",
+							mxc_fbi->dispdrv->drv->name);
+
+			if (!on_the_fly) {
+				ipu_clear_irq_late_init(mxc_fbi_fg->ipu, mxc_fbi_fg->ipu_ch_irq);
+				ipu_disable_irq_late_init(mxc_fbi_fg->ipu, mxc_fbi_fg->ipu_ch_irq);
+				ipu_clear_irq_late_init(mxc_fbi_fg->ipu, mxc_fbi_fg->ipu_ch_nf_irq);
+				ipu_disable_irq_late_init(mxc_fbi_fg->ipu, mxc_fbi_fg->ipu_ch_nf_irq);
+				if (mxc_fbi_fg->cur_prefetch) {
+					ipu_prg_disable(mxc_fbi_fg->ipu_id, mxc_fbi_fg->pre_num);
+					ipu_pre_disable(mxc_fbi_fg->pre_num);
+					ipu_pre_free(&mxc_fbi_fg->pre_num);
+				}
+			}
+		}
+
+		if (!on_the_fly) {
+			ipu_clear_irq_late_init(mxc_fbi->ipu, mxc_fbi->ipu_ch_irq);
+			ipu_disable_irq_late_init(mxc_fbi->ipu, mxc_fbi->ipu_ch_irq);
+			ipu_clear_irq_late_init(mxc_fbi->ipu, mxc_fbi->ipu_ch_nf_irq);
+			ipu_disable_irq_late_init(mxc_fbi->ipu, mxc_fbi->ipu_ch_nf_irq);
+			if (mxc_fbi->cur_prefetch) {
+				ipu_prg_disable(mxc_fbi->ipu_id, mxc_fbi->pre_num);
+				ipu_pre_disable(mxc_fbi->pre_num);
+				ipu_pre_free(&mxc_fbi->pre_num);
+			}
+                }
+	} else {
+#endif
 	if (ovfbi_enable) {
 		ov_pos_ret = ipu_disp_get_window_pos(
 						mxc_fbi_fg->ipu, mxc_fbi_fg->ipu_ch,
@@ -1209,6 +1303,9 @@ static int mxcfb_set_par(struct fb_info *fbi)
 	 */
 	if (mxc_fbi->first_set_par && mxc_fbi->late_init)
 		ipu_disable_hsp_clk(mxc_fbi->ipu);
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+	}
+#endif
 
 	mem_len = fbi->var.yres_virtual * fbi->fix.line_length;
 	if (mxc_fbi->resolve && mxc_fbi->gpu_sec_buf_off) {
@@ -1227,13 +1324,14 @@ static int mxcfb_set_par(struct fb_info *fbi)
 	}
 
 	if (mxc_fbi->first_set_par) {
+#ifndef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
 		/*
 		 * Clear the screen in case uboot fb pixel format is not
 		 * the same to kernel fb pixel format.
 		 */
 		if (mxc_fbi->late_init)
 			memset((char *)fbi->screen_base, 0, fbi->fix.smem_len);
-
+#endif
 		mxc_fbi->first_set_par = false;
 	}
 
@@ -1312,6 +1410,9 @@ static int mxcfb_set_par(struct fb_info *fbi)
 	}
 
 	if (!mxc_fbi->overlay && !on_the_fly) {
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+		if (!mxc_fbi->late_init) {
+#endif		
 		uint32_t out_pixel_fmt;
 
 		memset(&sig_cfg, 0, sizeof(sig_cfg));
@@ -1354,6 +1455,9 @@ static int mxcfb_set_par(struct fb_info *fbi)
 			return -EINVAL;
 		}
 
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+		}
+#endif
 		fbi->mode =
 		    (struct fb_videomode *)fb_match_mode(&fbi->var,
 							 &fbi->modelist);
@@ -1598,6 +1702,11 @@ static int mxcfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
 		bg_xres = fbi_tmp->var.xres;
 		bg_yres = fbi_tmp->var.yres;
 
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+		if (mxc_fbi->late_init)
+			ipu_disp_get_window_pos_late_init(mxc_fbi->ipu, mxc_fbi->ipu_ch, &pos_x, &pos_y);
+		else
+#endif
 		ipu_disp_get_window_pos(mxc_fbi->ipu, mxc_fbi->ipu_ch, &pos_x, &pos_y);
 
 		if ((var->xres + pos_x) > bg_xres)
@@ -2356,6 +2465,12 @@ static int mxcfb_blank(int blank, struct fb_info *info)
 				FB_ACTIVATE_NOW | FB_ACTIVATE_FORCE;
 		ret = fb_set_var(info, &info->var);
 	} else {
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+		if (mxc_fbi->late_init) {
+			if (mxc_fbi->dispdrv && mxc_fbi->dispdrv->drv->late_init_done)
+				mxc_fbi->dispdrv->drv->late_init_done(mxc_fbi->dispdrv);
+		}
+#endif
 		if (mxc_fbi->dispdrv && mxc_fbi->dispdrv->drv->disable)
 			mxc_fbi->dispdrv->drv->disable(mxc_fbi->dispdrv, info);
 		ipu_disable_channel(mxc_fbi->ipu, mxc_fbi->ipu_ch, true);
@@ -2368,6 +2483,12 @@ static int mxcfb_blank(int blank, struct fb_info *info)
 			ipu_pre_free(&mxc_fbi->pre_num);
 		}
 	}
+
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+		if (mxc_fbi->late_init)
+			mxc_fbi->late_init = false;
+#endif
+
 	if (!ret)
 		mxc_fbi->cur_blank = blank;
 	return ret;
@@ -3102,19 +3223,30 @@ EXPORT_SYMBOL_GPL(fb_vga_fix_id);
 static int mxcfb_option_setup(struct platform_device *pdev, struct fb_info *fbi)
 {
 	struct ipuv3_fb_platform_data *pdata = pdev->dev.platform_data;
-	char *options, *opt, *fb_mode_str = NULL;
+	char *options, *opt, *option, *fb_mode_str = NULL;
 	char name[] = "mxcfb0";
 	uint32_t fb_pix_fmt = 0;
 
 	name[5] += pdev->id;
-	if (fb_get_options(name, &options)) {
+	if (fb_get_options(name, &option)) {
 		dev_err(&pdev->dev, "Can't get fb option for %s!\n", name);
 		return -ENODEV;
 	}
 
-	if (!options || !*options)
+	if (!option || !*option)
 		return 0;
+#if  1
+	/*
+	*	Why we add this part?  the orignal code modify the video_options
+		data from cmdline. for everyone can use this data from cmdline,
+		this function should not modify this data.		
+	*/
+	options = devm_kzalloc(&pdev->dev, strlen(option)+1, GFP_KERNEL);
+	if(!options)
+		return -ENODEV;
 
+	strcpy(options, option);
+#endif
 	while ((opt = strsep(&options, ",")) != NULL) {
 		if (!*opt)
 			continue;
@@ -3182,7 +3314,13 @@ static int mxcfb_option_setup(struct platform_device *pdev, struct fb_info *fbi)
 			fb_pix_fmt = bpp_to_pixfmt(pdata->default_bpp);
 			if (fb_pix_fmt)
 				pixfmt_to_var(fb_pix_fmt, &fbi->var);
-		} else
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+		} else if (!strncmp(opt, "logo", 4)) {
+			pdata->logo = true;
+		}else if (!strncmp(opt, "bypass-reset=", 13)) {
+			/*Skip this, we have  parsed this in the early stage */
+#endif
+		}else
 			fb_mode_str = opt;
 	}
 
@@ -3192,6 +3330,148 @@ static int mxcfb_option_setup(struct platform_device *pdev, struct fb_info *fbi)
 	return 0;
 }
 
+/************* Support keep uboot logo to kernel ***************/
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+bool mxcfb_early_check_ipu_bypass_reset_status(int ipu_id)
+{
+	char name[] = "mxcfb0";
+	char ipu_dev[5];
+	char *options=NULL, *opt;
+	int i, bypass_reset=0;
+
+	/* Get the cmdline status*/
+	for(i=0 ;  i < 4; i++){
+		name[5] += i;
+		if (fb_get_options(name, &options)) 
+			continue;
+		if (!options || !*options) continue;
+
+		opt=strstr(options, "bypass-reset=");	
+		if(opt){
+			ipu_dev[0]=opt[13];
+			ipu_dev[1]='\0';  	
+			bypass_reset=simple_strtoul(ipu_dev, NULL, 0);
+			if(bypass_reset == ipu_id){		
+				return true;
+			}
+		}			
+	}
+
+	return false;
+}
+EXPORT_SYMBOL(mxcfb_early_check_ipu_bypass_reset_status);
+
+bool mxcfb_early_get_logo_status(char *dev)
+{
+	char name[] = "mxcfb0";
+	char fbdev[] = "fb@0";
+	char *options;
+	int i;
+	bool res = false;
+	struct device_node *np ;
+
+	/* Get the status from device tree*/
+	for(i=0 ;  i < 4; i++){
+		fbdev[3] +=i;
+		np =of_find_node_by_name(NULL, fbdev);
+		if(np){
+			if (!of_device_is_available(np)) {
+				of_node_put(np);
+				continue;
+			}
+			if(of_property_match_string(np, "disp_dev", dev) >=0)
+				if(of_property_read_bool(np, "logo"))
+					res = true;
+
+			of_node_put(np);
+		}	
+	}
+
+	/* Get the status from  cmdline */
+	for(i=0 ;  i < 4; i++){
+		name[5] += i;
+		if (fb_get_options(name, &options)) 
+			continue;
+		if (!options || !*options) continue;
+		if(strstr(options, dev))
+			if(strstr(options, "logo"))
+				res= true;		
+	}
+
+	return res;
+}
+
+
+bool  mxcfb_has_keeplogo(struct fb_info *fbi)
+{
+	struct mxcfb_info *mxcfbi = (struct mxcfb_info *)fbi->par;
+
+	return mxcfbi->logo;
+}
+
+static int mxc_clk_set_parent(char *clk, char * parent)
+{	
+	struct clk *clk1, *clk2;
+	unsigned long rate;
+	int ret;
+
+	clk1 = __clk_lookup(clk);
+	clk2 = __clk_lookup(parent);
+
+	if (clk1 && clk2) {
+		rate = clk_get_rate(clk1);
+
+		ret = clk_set_parent(clk1, clk2);
+		if (ret < 0)
+			pr_warn("%s: could not reparent %s to %s\n",
+				__func__, clk, parent);
+
+		clk_set_rate(clk1, rate);
+	} else {
+		pr_warn("%s: missing clocks to reparent %s to %s\n",
+			__func__, clk, parent);
+		ret = -1;
+	}
+
+	return ret;
+}
+
+int imx_ipuclk_set_parent(char*dev, int ipu_id, int ipu_di);
+static int mxcfb_clk_parent_reassign(char*dev, int ipu_id, int ipu_di)
+{
+	int ret = 0;
+	
+	imx_ipuclk_set_parent(dev, ipu_id, ipu_di);
+	/* Assigned the pixel clock source*/
+	/* LCD/HDMI/LVDS use ipu1 di0 as pixclock's clock source. */
+	if(ipu_id ==0 && ipu_di == 0){
+		ret= mxc_clk_set_parent("ipu1_pclk0_sel","ipu1_di0");
+		if(ret)
+			return ret;
+	}	
+	if (!strncmp(dev, "ldb", 3)){
+		if(ipu_id ==0 && ipu_di ==1){
+			ret= mxc_clk_set_parent("ipu1_pclk1_sel","ipu1_di1");
+			if(ret)
+				return ret; 
+		}else if(ipu_id ==1 && ipu_di == 1){
+			ret =mxc_clk_set_parent("ipu2_pclk1_sel","ipu2_di1");
+			if(ret)
+				return ret;	
+		}
+	}else if (!strncmp(dev, "hdmi", 4)){
+		if (ipu_id ==1 && ipu_di == 0){
+			ret = mxc_clk_set_parent("ipu2_pclk0_sel", "ipu2_di0");
+			if(ret)
+				return ret;
+		}	
+	}	
+	
+	return 0; 
+}
+#endif /*  CONFIG_MX6_CLK_FOR_BOOTUI_TRANS*/
+/**   End of  keep uboot logo to kernel **/
+
 static int mxcfb_register(struct fb_info *fbi)
 {
 	struct mxcfb_info *mxcfbi = (struct mxcfb_info *)fbi->par;
@@ -3222,6 +3502,37 @@ static int mxcfb_register(struct fb_info *fbi)
 	fb_var_to_videomode(&m, &fbi->var);
 	fb_add_videomode(&m, &fbi->modelist);
 
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+		if (mxcfbi->late_init) {
+			if (ipu_request_irq_late_init(mxcfbi->ipu, mxcfbi->ipu_ch_irq,
+				mxcfb_irq_handler, IPU_IRQF_ONESHOT, MXCFB_NAME, fbi) != 0) {
+				dev_err(fbi->device, "Error registering EOF irq handler.\n");
+				ret = -EBUSY;
+				goto err0;
+			}
+			ipu_disable_irq_late_init(mxcfbi->ipu, mxcfbi->ipu_ch_irq);
+
+			if (ipu_request_irq_late_init(mxcfbi->ipu, mxcfbi->ipu_ch_nf_irq,
+				mxcfb_nf_irq_handler, IPU_IRQF_ONESHOT, MXCFB_NAME, fbi) != 0) {
+				dev_err(fbi->device, "Error registering NFACK irq handler.\n");
+				ret = -EBUSY;
+				goto err1;
+			}
+			ipu_disable_irq_late_init(mxcfbi->ipu, mxcfbi->ipu_ch_nf_irq);
+
+			if (mxcfbi->ipu_alp_ch_irq != -1) {
+				if (ipu_request_irq_late_init(mxcfbi->ipu, mxcfbi->ipu_alp_ch_irq,
+							mxcfb_alpha_irq_handler, IPU_IRQF_ONESHOT,
+							MXCFB_NAME, fbi) != 0) {
+					dev_err(fbi->device, "Error registering alpha irq "
+							"handler.\n");
+					ret = -EBUSY;
+					goto err3;
+				}
+			}
+		} else {
+#endif
+
 	if (ipu_request_irq(mxcfbi->ipu, mxcfbi->ipu_ch_irq,
 		mxcfb_irq_handler, IPU_IRQF_ONESHOT, MXCFB_NAME, fbi) != 0) {
 		dev_err(fbi->device, "Error registering EOF irq handler.\n");
@@ -3247,6 +3558,10 @@ static int mxcfb_register(struct fb_info *fbi)
 			goto err2;
 		}
 
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+	}
+#endif
+
 	if (!mxcfbi->late_init) {
 		fbi->var.activate |= FB_ACTIVATE_FORCE;
 		console_lock();
@@ -3288,6 +3603,12 @@ static int mxcfb_register(struct fb_info *fbi)
 	if (ret < 0)
 		goto err5;
 
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+	if (mxcfbi->late_init && (mxcfbi->next_blank == FB_BLANK_UNBLANK)) {
+		mxcfbi->cur_var = fbi->var;
+		fbi->mode =(struct fb_videomode *)fb_match_mode(&fbi->var, &fbi->modelist);
+	}
+#endif
 	return ret;
 err5:
 	if (mxcfbi->next_blank == FB_BLANK_UNBLANK) {
@@ -3331,6 +3652,9 @@ static int mxcfb_setup_overlay(struct platform_device *pdev,
 		struct fb_info *fbi_bg, struct resource *res)
 {
 	struct fb_info *ovfbi;
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+	struct ipuv3_fb_platform_data *plat_data = pdev->dev.platform_data;
+#endif
 	struct mxcfb_info *mxcfbi_bg = (struct mxcfb_info *)fbi_bg->par;
 	struct mxcfb_info *mxcfbi_fg;
 	int ret = 0;
@@ -3359,6 +3683,9 @@ static int mxcfb_setup_overlay(struct platform_device *pdev,
 	mxcfbi_fg->prefetch = false;
 	mxcfbi_fg->resolve = false;
 	mxcfbi_fg->pre_num = -1;
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+	mxcfbi_fg->late_init = plat_data->late_init;
+#endif
 
 	/* Need dummy values until real panel is configured */
 	ovfbi->var.xres = 240;
@@ -3426,6 +3753,9 @@ static int mxcfb_get_of_property(struct platform_device *pdev,
 	int len;
 	u32 bpp, int_clk;
 	u32 late_init;
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+	u32 fb_base, fb_size;
+#endif
 
 	err = of_property_read_string(np, "disp_dev", &disp_dev);
 	if (err < 0) {
@@ -3455,7 +3785,15 @@ static int mxcfb_get_of_property(struct platform_device *pdev,
 		dev_dbg(&pdev->dev, "get of property late_init fail\n");
 		return err;
 	}
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+	if (of_property_read_u32(np, "fb_base", &fb_base)) {
+		fb_base = 0;
+	}
 
+	if (of_property_read_u32(np, "fb_size", &fb_size)) {
+		fb_size = 0;
+	}
+#endif	
 	plat_data->prefetch = of_property_read_bool(np, "prefetch");
 
 	if (!strncmp(pixfmt, "RGB24", 5))
@@ -3492,6 +3830,10 @@ static int mxcfb_get_of_property(struct platform_device *pdev,
 	plat_data->default_bpp = bpp;
 	plat_data->int_clk = (bool)int_clk;
 	plat_data->late_init = (bool)late_init;
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+	plat_data->res_base[0] = fb_base;
+	plat_data->res_size[0] = fb_size;
+#endif
 	return err;
 }
 
@@ -3524,6 +3866,7 @@ static int mxcfb_probe(struct platform_device *pdev)
 	if (!plat_data)
 		return -ENOMEM;
 	pdev->dev.platform_data = plat_data;
+	plat_data->logo = false;
 
 	ret = mxcfb_get_of_property(pdev, plat_data);
 	if (ret < 0) {
@@ -3532,6 +3875,7 @@ static int mxcfb_probe(struct platform_device *pdev)
 	}
 
 #if defined(CONFIG_OF) && defined(CONFIG_ARCH_ADVANTECH)
+#ifndef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
 	if(first_power_on) {
 		printk(KERN_INFO "[LVDS Sequence] 1 Start to enable LVDS VDD.\n");
 
@@ -3540,6 +3884,7 @@ static int mxcfb_probe(struct platform_device *pdev)
 		printk(KERN_INFO "[LVDS Sequence] 2 Start to enable LVDS signal.\n");
 	}
 #endif
+#endif
 
 	/* Initialize FB structures */
 	fbi = mxcfb_init_fbinfo(&pdev->dev, &mxcfb_ops);
@@ -3558,12 +3903,29 @@ static int mxcfb_probe(struct platform_device *pdev)
 	mxcfbi->first_set_par = true;
 	mxcfbi->prefetch = plat_data->prefetch;
 	mxcfbi->pre_num = -1;
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+	mxcfbi->logo =plat_data->logo;
+	if(mxcfbi->logo){
+		mxcfbi->late_init = 1;
+		plat_data->late_init = 1;
+		mxcfbi->late_init_idmac_done = false;
+	}else {
+		plat_data->late_init = 0;
+		mxcfbi->late_init = 0;
+	}
+#endif
 	spin_lock_init(&mxcfbi->spin_lock);
 
 	ret = mxcfb_dispdrv_init(pdev, fbi);
 	if (ret < 0)
 		goto init_dispdrv_failed;
 
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+	if(mxcfbi->logo){
+		printk(KERN_INFO "############# LOGO   ---> ###########.\n");
+		mxcfb_clk_parent_reassign(plat_data->disp_dev, mxcfbi->ipu_id, mxcfbi->ipu_di);
+	}
+#endif
 	ret = ipu_test_set_usage(mxcfbi->ipu_id, mxcfbi->ipu_di);
 	if (ret < 0) {
 		dev_err(&pdev->dev, "ipu%d-di%d already in use\n",
@@ -3571,6 +3933,16 @@ static int mxcfb_probe(struct platform_device *pdev)
 		goto ipu_in_busy;
 	}
 
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+	if (plat_data->res_base[0] && plat_data->res_size[0]) {
+		fbi->fix.smem_len = plat_data->res_size[0];
+		fbi->fix.smem_start = plat_data->res_base[0];
+		fbi->screen_base = ioremap(fbi->fix.smem_start, fbi->fix.smem_len);
+		/* Do not clear the fb content drawn in bootloader. */
+		if (!mxcfbi->late_init)
+			memset(fbi->screen_base, 0, fbi->fix.smem_len);
+	}
+#else
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (res && res->start && res->end) {
 		fbi->fix.smem_len = res->end - res->start + 1;
@@ -3580,7 +3952,7 @@ static int mxcfb_probe(struct platform_device *pdev)
 		if (!mxcfbi->late_init)
 			memset(fbi->screen_base, 0, fbi->fix.smem_len);
 	}
-
+#endif
 	mxcfbi->ipu = ipu_get_soc(mxcfbi->ipu_id);
 	if (IS_ERR(mxcfbi->ipu)) {
 		ret = -ENODEV;
@@ -3609,10 +3981,19 @@ static int mxcfb_probe(struct platform_device *pdev)
 		if (ret < 0)
 			goto mxcfb_register_failed;
 
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+		if (mxcfbi->late_init) {
+			ipu_disp_set_global_alpha_late_init(mxcfbi->ipu, mxcfbi->ipu_ch,
+						  true, 0x80);
+			ipu_disp_set_color_key_late_init(mxcfbi->ipu, mxcfbi->ipu_ch, false, 0);
+		} else {
+#endif
 		ipu_disp_set_global_alpha(mxcfbi->ipu, mxcfbi->ipu_ch,
 					  true, 0x80);
 		ipu_disp_set_color_key(mxcfbi->ipu, mxcfbi->ipu_ch, false, 0);
-
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+		}
+#endif
 		res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
 		ret = mxcfb_setup_overlay(pdev, fbi, res);
 
diff --git a/include/linux/ipu-v3.h b/include/linux/ipu-v3.h
index ae09614..36dda2a 100644
--- a/include/linux/ipu-v3.h
+++ b/include/linux/ipu-v3.h
@@ -765,6 +765,32 @@ struct ipuv3_fb_platform_data {
 
 	/* Enable the PRE resolve engine or not? */
 	bool				resolve;
+
+	/* Enable  keep the logo from uboot to kernel */
+	bool				logo;
 };
 
+
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+void ipu_disable_irq_late_init(struct ipu_soc *ipu, uint32_t irq);
+void ipu_clear_irq_late_init(struct ipu_soc *ipu, uint32_t irq);
+int ipu_request_irq_late_init(struct ipu_soc *ipu, uint32_t irq,
+                                irqreturn_t(*handler) (int, void *),
+                                uint32_t irq_flags, const char *devname, void *dev_id);
+int32_t ipu_disp_get_window_pos_late_init(struct ipu_soc *ipu, ipu_channel_t channel, int16_t *x_pos,
+                                int16_t *y_pos);
+int32_t ipu_disp_set_global_alpha_late_init(struct ipu_soc *ipu, ipu_channel_t channel, bool enable,
+                                  uint8_t alpha);
+int32_t ipu_disp_set_color_key_late_init(struct ipu_soc *ipu, ipu_channel_t channel, bool enable,
+                               uint32_t colorKey);
+int32_t ipu_init_channel_late_init(struct ipu_soc *ipu, ipu_channel_t channel, ipu_channel_params_t *params);
+int32_t ipu_init_channel_buffer_late_init(struct ipu_soc *ipu, ipu_channel_t channel, ipu_buffer_t type,
+                                uint32_t pixel_fmt,
+                                uint16_t width, uint16_t height,
+                                uint32_t stride,
+                                ipu_rotate_mode_t rot_mode,
+                                dma_addr_t phyaddr_0, dma_addr_t phyaddr_1,
+                                dma_addr_t phyaddr_2,
+                                uint32_t u, uint32_t v);
+#endif
 #endif /* __LINUX_IPU_V3_H_ */
diff --git a/include/linux/mfd/mxc-hdmi-core.h b/include/linux/mfd/mxc-hdmi-core.h
index b2696b9..7ca8cf6 100644
--- a/include/linux/mfd/mxc-hdmi-core.h
+++ b/include/linux/mfd/mxc-hdmi-core.h
@@ -52,5 +52,6 @@ void mxc_hdmi_unregister_audio(struct snd_pcm_substream *substream);
 unsigned int hdmi_set_cable_state(unsigned int state);
 unsigned int hdmi_set_blank_state(unsigned int state);
 int check_hdmi_state(void);
+void hdmi_init_pclk(unsigned long pclk);
 
 #endif
diff --git a/include/linux/mxcfb.h b/include/linux/mxcfb.h
index 67db5ee..091dc4c 100644
--- a/include/linux/mxcfb.h
+++ b/include/linux/mxcfb.h
@@ -43,4 +43,9 @@ int mxc_elcdif_frame_addr_setup(dma_addr_t phys);
 void mxcfb_elcdif_register_mode(const struct fb_videomode *modedb,
 		int num_modes, int dev_mode);
 
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+bool mxcfb_early_get_logo_status(char *dev);
+bool mxcfb_early_check_ipu_bypass_reset_status(int ipu_id);
+#endif
+
 #endif
diff --git a/kernel/power/process.c b/kernel/power/process.c
old mode 100644
new mode 100755
